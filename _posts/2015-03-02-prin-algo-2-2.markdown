---

layout: post

title: "Princeton ALgorithm Week 2-2， Sorting"

categories: jekyll update 

---

## interface Comparable<Item>
int compareTo(Item item)

`implements Comparable<item>` 这个接口包含`int compareTo(Item item)`
		
		-1: less than
		0: equal
		1: large than

目前使用`implements Comparable<item>`只是可以直接调用`compareTo`实现比较，但是相信在后面的sort里面可以直接应用从而排序一系列对象。

## interface Comparator<Item>

有的Class是我们不能设计的，不能修改的。那么我们无法Implement Comparable。这个时候，我们还是需要比较或者排序的，那么我们该怎么办呢。

这时候Java中有一个新的interface Comparator。他允许你作为第三者比较Item。其中需要实现的API有 `int compara(Item t1, Item t2)`.


## Selection Sort
从第一个开始，每次找后面序列中最小的一个交换到当前位。

比较次数是N^2/2，交换次数是N。

## Insertion Sort
对于每一个元素，在前面已排序序列中找到正确的位置插入。

Worst case & Best case

这里的做法是反向交换元素直到合适的位置停止。这样做，增加了一些交换的次数，因为相比直接插入而言，比较的次数是相同的。而直接插入需要数据结构的支持。

## Shellsort 
以一个increment array作为间隔，对数据进行排序。

The worst case: N^(3/2)

代码量小，是现在嵌入式系统中（序列的规模很小，算法比较效率）


## Plus: Application

### Shuffling
Random a list.

对于每一个i位置的元素，产生1~i其中一个随机数r，交换元素i和r。这样结束可以拿到一个随意混乱的list。

### Convex Hull
#### 一个问题的解决方案：

1. 找到一个切入点：x/y坐标最大（小）的一个点
2. 推进：摆角排序

#### Detail
1. 怎么找到最小的y坐标点
2. 对摆角进行排序
3. a->b->c clockwise turn

	
## 比较排序算法

1. Selection：需要较少的交换次数 N
2. Insertion：对于partially sorted的序列更好用

## 练习题

1. 4个数，最少可以用5次比较排序
2. 5个数，最少可以用9次比较排序
3. 6个数，最少可以用12次比较排序